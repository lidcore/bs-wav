// Generated by BUCKLESCRIPT VERSION 4.0.17, PLEASE EDIT WITH CARE
'use strict';

var Caml_array = require("bs-platform/lib/js/caml_array.js");
var BsAsyncMonad = require("bs-async-monad/src/bsAsyncMonad.js");
var Fs$LidcoreBsNode = require("@lidcore/bs-node/src/fs.js");
var Wav$LidcoreBsWav = require("../src/wav.js");
var Buffer$LidcoreBsNode = require("@lidcore/bs-node/src/buffer.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var usage = "Usage: wavinfo /path/to/input.wav /path/to/output.wav";

function readFile(position, path) {
  var stats = Fs$LidcoreBsNode.statSync(path);
  var size = stats.size;
  var length = size - position;
  var content = Buffer$LidcoreBsNode.alloc(size);
  return BsAsyncMonad.Callback[/* >> */3]((function (param) {
                return Fs$LidcoreBsNode.openFile(path, "r", param);
              }), (function (fd) {
                var partial_arg = position;
                return BsAsyncMonad.Callback[/* &> */9](BsAsyncMonad.Callback[/* >> */3]((function (param) {
                                  return Fs$LidcoreBsNode.read(partial_arg, undefined, undefined, fd, content, param);
                                }), (function (param) {
                                  if (param[0] !== length) {
                                    throw [
                                          Caml_builtin_exceptions.assert_failure,
                                          /* tuple */[
                                            "wavcp.ml",
                                            21,
                                            6
                                          ]
                                        ];
                                  }
                                  var partial_arg = BsAsyncMonad.Callback[/* return */0];
                                  return (function (param) {
                                      return partial_arg(content, param);
                                    });
                                })), (function (param) {
                              return (function (param) {
                                  return Fs$LidcoreBsNode.close(fd, param);
                                });
                            }));
              }));
}

var match;

try {
  match = /* tuple */[
    Caml_array.caml_array_get(process.argv, 2),
    Caml_array.caml_array_get(process.argv, 3)
  ];
}
catch (exn){
  console.log(usage);
  match = process.exit(1);
}

var output = match[1];

var input = match[0];

BsAsyncMonad.Callback[/* finish */31](undefined, BsAsyncMonad.Callback[/* >> */3](Wav$LidcoreBsWav.read(input), (function (wav) {
            var header = wav.header;
            var position = wav.data_offset;
            return BsAsyncMonad.Callback[/* >> */3](readFile(position, input), (function (data) {
                          return Wav$LidcoreBsWav.write(header, data, output);
                        }));
          })));

exports.usage = usage;
exports.readFile = readFile;
/* match Not a pure module */
