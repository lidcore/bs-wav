// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array = require("bs-platform/lib/js/array.js");
var BsCallback = require("bs-callback/src/bsCallback.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Fs$LidcoreBsNode = require("@lidcore/bs-node/src/fs.js");
var Buffer$LidcoreBsNode = require("@lidcore/bs-node/src/buffer.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var Not_a_wav_file = Caml_exceptions.create("Wav-LidcoreBsWav.Not_a_wav_file");

var buf = Buffer$LidcoreBsNode.from(/* None */0, " ");

function input_byte(ic) {
  var partial_arg = ic.fd;
  return BsCallback.$great$great((function (param) {
                return Fs$LidcoreBsNode.read(/* None */0, partial_arg, buf, 0, 1, param);
              }), (function (param) {
                if (param[0] !== 1) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "wav.ml",
                          26,
                          4
                        ]
                      ];
                }
                ic.offset = ic.offset + 1 | 0;
                var partial_arg = Buffer$LidcoreBsNode.get(param[1], 0);
                return (function (param) {
                    return BsCallback.$$return(partial_arg, param);
                  });
              }));
}

function read_float_num_bytes(ic, len) {
  var l = $$Array.to_list(Caml_array.caml_make_vect(len, 0));
  return BsCallback.fold_lefti(/* None */0, (function (cur, idx, _) {
                return BsCallback.$great$great(input_byte(ic), (function (b) {
                              var partial_arg = b * Math.pow(256, idx) + cur;
                              return (function (param) {
                                  return BsCallback.$$return(partial_arg, param);
                                });
                            }));
              }), (function (param) {
                return BsCallback.$$return(0, param);
              }), l);
}

function read_int(ic) {
  return BsCallback.$great$great(read_float_num_bytes(ic, 4), (function (ret) {
                var partial_arg = ret | 0;
                return (function (param) {
                    return BsCallback.$$return(partial_arg, param);
                  });
              }));
}

function read_short(ic) {
  return BsCallback.$great$great(read_float_num_bytes(ic, 2), (function (ret) {
                var partial_arg = ret | 0;
                return (function (param) {
                    return BsCallback.$$return(partial_arg, param);
                  });
              }));
}

function read_string(ic, n) {
  var n$1 = n;
  var buf = Buffer$LidcoreBsNode.alloc(n$1);
  var partial_arg = ic.fd;
  return BsCallback.$great$great((function (param) {
                return Fs$LidcoreBsNode.read(/* None */0, partial_arg, buf, 0, n$1, param);
              }), (function (param) {
                var ret = param[0];
                if (ret !== n$1) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "wav.ml",
                          53,
                          4
                        ]
                      ];
                }
                ic.offset = ic.offset + (ret | 0) | 0;
                var partial_arg = Buffer$LidcoreBsNode.toString(param[1]);
                return (function (param) {
                    return BsCallback.$$return(partial_arg, param);
                  });
              }));
}

function read(path) {
  var check = function (condition, reason) {
    if (condition) {
      return (function (param) {
          return BsCallback.$$return(/* () */0, param);
        });
    } else {
      var partial_arg = [
        Not_a_wav_file,
        reason
      ];
      return (function (param) {
          return BsCallback.fail(partial_arg, param);
        });
    }
  };
  var fmt_len = [-1];
  var chan_num = [-1];
  var samp_hz = [-1];
  var byt_per_sec = [-1];
  var byt_per_samp = [-1];
  var bit_per_samp = [-1];
  return BsCallback.$great$great((function (param) {
                return Fs$LidcoreBsNode.openFile(path, "r", param);
              }), (function (fd) {
                var ic = {
                  fd: fd,
                  offset: 0
                };
                var partial_arg = read_int(ic);
                var tmp;
                if (fmt_len[0] > 16) {
                  var partial_arg$1 = read_float_num_bytes(ic, fmt_len[0] - 16 | 0);
                  tmp = (function (param) {
                      return BsCallback.discard(partial_arg$1, param);
                    });
                } else {
                  tmp = (function (param) {
                      return BsCallback.$$return(/* () */0, param);
                    });
                }
                return BsCallback.$great$great(BsCallback.seqa(/* None */0, /* array */[
                                BsCallback.$great$great(read_string(ic, 4), (function (ret) {
                                        return check(ret === "RIFF", "Bad header: \"RIFF\" expected");
                                      })),
                                (function (param) {
                                    return BsCallback.discard(partial_arg, param);
                                  }),
                                BsCallback.$great$great(read_string(ic, 4), (function (ret) {
                                        return check(ret === "WAVE", "Bad header: \"WAVE\" expected");
                                      })),
                                BsCallback.$great$great(read_string(ic, 4), (function (ret) {
                                        return check(ret === "fmt ", "Bad header: \"fmt \" expected");
                                      })),
                                BsCallback.$great$great(read_int(ic), (function (ret) {
                                        fmt_len[0] = ret;
                                        return check(ret >= 16, "Bad header: invalid \"fmt \" length");
                                      })),
                                BsCallback.$great$great(read_short(ic), (function (ret) {
                                        return check(ret === 1, "Bad header: unhandled codec");
                                      })),
                                BsCallback.$great$great(read_short(ic), (function (ret) {
                                        chan_num[0] = ret;
                                        return (function (param) {
                                            return BsCallback.$$return(/* () */0, param);
                                          });
                                      })),
                                BsCallback.$great$great(read_int(ic), (function (ret) {
                                        samp_hz[0] = ret;
                                        return (function (param) {
                                            return BsCallback.$$return(/* () */0, param);
                                          });
                                      })),
                                BsCallback.$great$great(read_int(ic), (function (ret) {
                                        byt_per_sec[0] = ret;
                                        return (function (param) {
                                            return BsCallback.$$return(/* () */0, param);
                                          });
                                      })),
                                BsCallback.$great$great(read_short(ic), (function (ret) {
                                        byt_per_samp[0] = ret;
                                        return (function (param) {
                                            return BsCallback.$$return(/* () */0, param);
                                          });
                                      })),
                                BsCallback.$great$great(read_short(ic), (function (ret) {
                                        bit_per_samp[0] = ret;
                                        return (function (param) {
                                            return BsCallback.$$return(/* () */0, param);
                                          });
                                      })),
                                tmp,
                                BsCallback.$great$great(read_string(ic, 4), (function (ret) {
                                        var header = [ret];
                                        var partial_arg = BsCallback.$great$great(read_int(ic), (function (len) {
                                                var partial_arg = read_string(ic, len);
                                                return BsCallback.$great$great((function (param) {
                                                              return BsCallback.discard(partial_arg, param);
                                                            }), (function () {
                                                              return BsCallback.$great$great(read_string(ic, 4), (function (ret) {
                                                                            header[0] = ret;
                                                                            return (function (param) {
                                                                                return BsCallback.$$return(/* () */0, param);
                                                                              });
                                                                          }));
                                                            }));
                                              }));
                                        var partial_arg$1 = header[0] !== "data";
                                        var partial_arg$2 = function (param) {
                                          return BsCallback.$$return(partial_arg$1, param);
                                        };
                                        return (function (param) {
                                            return BsCallback.repeat(partial_arg$2, partial_arg, param);
                                          });
                                      }))
                              ]), (function () {
                              return BsCallback.$great$great(read_int(ic), (function (length) {
                                            return BsCallback.$great$great((function (param) {
                                                          return Fs$LidcoreBsNode.close(fd, param);
                                                        }), (function () {
                                                          var partial_arg = {
                                                            channels: chan_num[0],
                                                            sample_rate: samp_hz[0],
                                                            bytes_per_second: byt_per_sec[0],
                                                            bytes_per_sample: byt_per_samp[0],
                                                            bits_per_sample: bit_per_samp[0],
                                                            data_offset: ic.offset,
                                                            duration: length / byt_per_sec[0]
                                                          };
                                                          return (function (param) {
                                                              return BsCallback.$$return(partial_arg, param);
                                                            });
                                                        }));
                                          }));
                            }));
              }));
}

exports.Not_a_wav_file = Not_a_wav_file;
exports.read = read;
/* buf Not a pure module */
