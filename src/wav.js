// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Js_mapperRt = require("bs-platform/lib/js/js_mapperRt.js");
var BsAsyncMonad = require("bs-async-monad/src/bsAsyncMonad.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Fs$LidcoreBsNode = require("@lidcore/bs-node/src/fs.js");
var Buffer$LidcoreBsNode = require("@lidcore/bs-node/src/buffer.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var jsMapperConstantArray = /* array */[
  1,
  3,
  6,
  7,
  65534
];

function format_codeToJs(param) {
  return Js_mapperRt.toInt(param, jsMapperConstantArray);
}

function format_codeFromJs(param) {
  return Js_mapperRt.fromInt(5, jsMapperConstantArray, param);
}

var Not_a_wav_file = Caml_exceptions.create("Wav-LidcoreBsWav.Not_a_wav_file");

var Not_supported = Caml_exceptions.create("Wav-LidcoreBsWav.Not_supported");

var buf = Buffer$LidcoreBsNode.from(/* None */0, " ");

function input_byte(ic) {
  var partial_arg = ic.fd;
  return BsAsyncMonad.Callback[/* >> */5]((function (param) {
                return Fs$LidcoreBsNode.read(/* None */0, /* None */0, /* None */0, partial_arg, buf, param);
              }), (function (param) {
                if (param[0] !== 1) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "wav.ml",
                          40,
                          4
                        ]
                      ];
                }
                ic.offset = ic.offset + 1 | 0;
                var partial_arg = Buffer$LidcoreBsNode.get(param[1], 0);
                var partial_arg$1 = BsAsyncMonad.Callback[/* return */2];
                return (function (param) {
                    return partial_arg$1(partial_arg, param);
                  });
              }));
}

function read_float_num_bytes(ic, len) {
  var l = $$Array.to_list(Caml_array.caml_make_vect(len, 0));
  var partial_arg = BsAsyncMonad.Callback[/* return */2];
  return BsAsyncMonad.Callback[/* fold_lefti */16](/* None */0, (function (cur, idx, _) {
                return BsAsyncMonad.Callback[/* >> */5](input_byte(ic), (function (b) {
                              var partial_arg = b * Math.pow(256, idx) + cur;
                              var partial_arg$1 = BsAsyncMonad.Callback[/* return */2];
                              return (function (param) {
                                  return partial_arg$1(partial_arg, param);
                                });
                            }));
              }), (function (param) {
                return partial_arg(0, param);
              }), l);
}

function read_int(ic) {
  return BsAsyncMonad.Callback[/* >> */5](read_float_num_bytes(ic, 4), (function (ret) {
                var partial_arg = ret | 0;
                var partial_arg$1 = BsAsyncMonad.Callback[/* return */2];
                return (function (param) {
                    return partial_arg$1(partial_arg, param);
                  });
              }));
}

function read_short(ic) {
  return BsAsyncMonad.Callback[/* >> */5](read_float_num_bytes(ic, 2), (function (ret) {
                var partial_arg = ret | 0;
                var partial_arg$1 = BsAsyncMonad.Callback[/* return */2];
                return (function (param) {
                    return partial_arg$1(partial_arg, param);
                  });
              }));
}

function read_string(ic, n) {
  var n$1 = n;
  var buf = Buffer$LidcoreBsNode.alloc(n$1);
  var partial_arg = ic.fd;
  return BsAsyncMonad.Callback[/* >> */5]((function (param) {
                return Fs$LidcoreBsNode.read(/* None */0, /* None */0, /* None */0, partial_arg, buf, param);
              }), (function (param) {
                var ret = param[0];
                if (ret !== n$1) {
                  throw [
                        Caml_builtin_exceptions.assert_failure,
                        [
                          "wav.ml",
                          67,
                          4
                        ]
                      ];
                }
                ic.offset = ic.offset + (ret | 0) | 0;
                var partial_arg = Buffer$LidcoreBsNode.toString(/* None */0, /* None */0, /* None */0, param[1]);
                var partial_arg$1 = BsAsyncMonad.Callback[/* return */2];
                return (function (param) {
                    return partial_arg$1(partial_arg, param);
                  });
              }));
}

function find_chunk(ic, id) {
  return BsAsyncMonad.Callback[/* >> */5](read_string(ic, 4), (function (ret) {
                var chunk_header = [ret];
                var partial_arg = BsAsyncMonad.Callback[/* repeat */13];
                return (function (param) {
                    return partial_arg((function () {
                                  var partial_arg = chunk_header[0] !== id;
                                  var partial_arg$1 = BsAsyncMonad.Callback[/* return */2];
                                  return (function (param) {
                                      return partial_arg$1(partial_arg, param);
                                    });
                                }), (function () {
                                  return BsAsyncMonad.Callback[/* >> */5](read_int(ic), (function (len) {
                                                var len$1 = len + len % 2 | 0;
                                                var partial_arg = read_string(ic, len$1);
                                                var partial_arg$1 = BsAsyncMonad.Callback[/* discard */12];
                                                return BsAsyncMonad.Callback[/* >> */5]((function (param) {
                                                              return partial_arg$1(partial_arg, param);
                                                            }), (function () {
                                                              return BsAsyncMonad.Callback[/* >> */5](read_string(ic, 4), (function (ret) {
                                                                            chunk_header[0] = ret;
                                                                            var partial_arg = BsAsyncMonad.Callback[/* return */2];
                                                                            return (function (param) {
                                                                                return partial_arg(/* () */0, param);
                                                                              });
                                                                          }));
                                                            }));
                                              }));
                                }), param);
                  });
              }));
}

function read(fd) {
  var check = function (condition, reason) {
    if (condition) {
      var partial_arg = [
        Not_a_wav_file,
        reason
      ];
      var partial_arg$1 = BsAsyncMonad.Callback[/* fail */3];
      return (function (param) {
          return partial_arg$1(partial_arg, param);
        });
    } else {
      var partial_arg$2 = BsAsyncMonad.Callback[/* return */2];
      return (function (param) {
          return partial_arg$2(/* () */0, param);
        });
    }
  };
  var remaining_fmt_len = [-1];
  var format_code = [-1];
  var chan_num = [-1];
  var samp_hz = [-1];
  var byt_per_sec = [-1];
  var byt_per_samp = [-1];
  var bit_per_samp = [-1];
  var ic = {
    fd: fd,
    offset: 0
  };
  var partial_arg = read_int(ic);
  var partial_arg$1 = BsAsyncMonad.Callback[/* discard */12];
  var tmp;
  if (remaining_fmt_len[0] > 0) {
    var partial_arg$2 = read_float_num_bytes(ic, remaining_fmt_len[0]);
    var partial_arg$3 = BsAsyncMonad.Callback[/* discard */12];
    tmp = (function (param) {
        return partial_arg$3(partial_arg$2, param);
      });
  } else {
    var partial_arg$4 = BsAsyncMonad.Callback[/* return */2];
    tmp = (function (param) {
        return partial_arg$4(/* () */0, param);
      });
  }
  return BsAsyncMonad.Callback[/* >> */5](BsAsyncMonad.Callback[/* seqa */23](/* None */0, /* array */[
                  BsAsyncMonad.Callback[/* >> */5](read_string(ic, 4), (function (ret) {
                          return check(ret !== "RIFF", "Bad header: \"RIFF\" expected");
                        })),
                  (function (param) {
                      return partial_arg$1(partial_arg, param);
                    }),
                  BsAsyncMonad.Callback[/* >> */5](read_string(ic, 4), (function (ret) {
                          return check(ret !== "WAVE", "Bad header: \"WAVE\" expected");
                        })),
                  find_chunk(ic, "fmt "),
                  BsAsyncMonad.Callback[/* >> */5](read_int(ic), (function (ret) {
                          remaining_fmt_len[0] = (ret + ret % 2 | 0) - 16 | 0;
                          return check(!List.mem(ret, /* :: */[
                                          16,
                                          /* :: */[
                                            18,
                                            /* :: */[
                                              40,
                                              /* [] */0
                                            ]
                                          ]
                                        ]), "Bad header: invalid \"fmt \" length");
                        })),
                  BsAsyncMonad.Callback[/* >> */5](read_short(ic), (function (code) {
                          format_code[0] = code;
                          return check(!List.mem(code, /* :: */[
                                          1,
                                          /* :: */[
                                            3,
                                            /* :: */[
                                              6,
                                              /* :: */[
                                                7,
                                                /* :: */[
                                                  65534,
                                                  /* [] */0
                                                ]
                                              ]
                                            ]
                                          ]
                                        ]), "Bad header: unhandled codec");
                        })),
                  BsAsyncMonad.Callback[/* >| */9](read_short(ic), (function (ret) {
                          chan_num[0] = ret;
                          return /* () */0;
                        })),
                  BsAsyncMonad.Callback[/* >| */9](read_int(ic), (function (ret) {
                          samp_hz[0] = ret;
                          return /* () */0;
                        })),
                  BsAsyncMonad.Callback[/* >| */9](read_int(ic), (function (ret) {
                          byt_per_sec[0] = ret;
                          return /* () */0;
                        })),
                  BsAsyncMonad.Callback[/* >| */9](read_short(ic), (function (ret) {
                          byt_per_samp[0] = ret;
                          return /* () */0;
                        })),
                  BsAsyncMonad.Callback[/* >| */9](read_short(ic), (function (ret) {
                          bit_per_samp[0] = ret;
                          return /* () */0;
                        })),
                  tmp,
                  find_chunk(ic, "data")
                ]), (function () {
                return BsAsyncMonad.Callback[/* >| */9](read_int(ic), (function (length) {
                              var header = {
                                channels: chan_num[0],
                                format_code: format_code[0],
                                sample_rate: samp_hz[0],
                                bytes_per_second: byt_per_sec[0],
                                bytes_per_sample: byt_per_samp[0],
                                bits_per_sample: bit_per_samp[0]
                              };
                              return {
                                      header: header,
                                      data_offset: ic.offset,
                                      duration: length / byt_per_sec[0]
                                    };
                            }));
              }));
}

function read$1(path) {
  return BsAsyncMonad.Callback[/* >> */5]((function (param) {
                return Fs$LidcoreBsNode.openFile(path, "r", param);
              }), (function (fd) {
                return BsAsyncMonad.Callback[/* &> */11](read(fd), (function () {
                              return (function (param) {
                                  return Fs$LidcoreBsNode.close(fd, param);
                                });
                            }));
              }));
}

function short_string(i) {
  var up = i / 256 | 0;
  var down = i - (up << 8) | 0;
  var pre = $$String.make(1, Pervasives.char_of_int(down));
  var post = $$String.make(1, Pervasives.char_of_int(up));
  return /* `String */[
          -976970511,
          "" + (String(pre) + ("" + (String(post) + "")))
        ];
}

function int_string(n) {
  var b = Caml_string.caml_create_string(4);
  b[0] = Pervasives.char_of_int(n & 255);
  b[1] = Pervasives.char_of_int(((n & 65280) >>> 8));
  b[2] = Pervasives.char_of_int(((n & 16711680) >>> 16));
  b[3] = Pervasives.char_of_int(((n & 2130706432) >>> 24));
  return /* `String */[
          -976970511,
          Bytes.to_string(b)
        ];
}

function write(header, data, path) {
  var match = format_codeFromJs(header.format_code);
  if (match) {
    if (match[0] !== 0) {
      var partial_arg = BsAsyncMonad.Callback[/* fail */3];
      return (function (param) {
          return partial_arg(Not_supported, param);
        });
    } else {
      var header$1 = header;
      var data$1 = data;
      var path$1 = path;
      return BsAsyncMonad.Callback[/* >> */5]((function (param) {
                    return Fs$LidcoreBsNode.openFile(path$1, "w", param);
                  }), (function (fd) {
                    var write = function (param, param$1) {
                      var fd$1 = fd;
                      var data = param;
                      var cb = param$1;
                      var written = [0];
                      var match;
                      if (data[0] >= 86585632) {
                        var data$1 = data[1];
                        match = /* tuple */[
                          Buffer$LidcoreBsNode.length(data$1) | 0,
                          data$1
                        ];
                      } else {
                        var data$2 = data[1];
                        match = /* tuple */[
                          data$2.length,
                          Buffer$LidcoreBsNode.from(/* Some */["binary"], data$2)
                        ];
                      }
                      var buf = match[1];
                      var len = match[0];
                      return BsAsyncMonad.Callback[/* repeat */13]((function () {
                                    var partial_arg = written[0] < len;
                                    var partial_arg$1 = BsAsyncMonad.Callback[/* return */2];
                                    return (function (param) {
                                        return partial_arg$1(partial_arg, param);
                                      });
                                  }), (function () {
                                    var offset = written[0];
                                    var partial_arg = /* Some */[offset];
                                    return BsAsyncMonad.Callback[/* >> */5]((function (param) {
                                                  return Fs$LidcoreBsNode.write(/* None */0, partial_arg, /* None */0, fd$1, buf, param);
                                                }), (function (param) {
                                                  written[0] = written[0] + (param[0] | 0) | 0;
                                                  var partial_arg = BsAsyncMonad.Callback[/* return */2];
                                                  return (function (param) {
                                                      return partial_arg(/* () */0, param);
                                                    });
                                                }));
                                  }), cb);
                    };
                    var dlen = Buffer$LidcoreBsNode.length(data$1) | 0;
                    var partial_arg = /* `String */[
                      -976970511,
                      "RIFF"
                    ];
                    var partial_arg$1 = int_string(36 + dlen | 0);
                    var partial_arg$2 = /* `String */[
                      -976970511,
                      "WAVE"
                    ];
                    var partial_arg$3 = /* `String */[
                      -976970511,
                      "fmt "
                    ];
                    var partial_arg$4 = int_string(16);
                    var partial_arg$5 = short_string(header$1.format_code);
                    var partial_arg$6 = short_string(header$1.channels);
                    var partial_arg$7 = int_string(header$1.sample_rate);
                    var partial_arg$8 = int_string(header$1.bytes_per_second);
                    var partial_arg$9 = short_string(header$1.bytes_per_sample);
                    var partial_arg$10 = short_string(header$1.bits_per_sample);
                    var partial_arg$11 = /* `String */[
                      -976970511,
                      "data"
                    ];
                    var partial_arg$12 = int_string(dlen);
                    var partial_arg$13 = /* `Buffer */[
                      86585632,
                      data$1
                    ];
                    return BsAsyncMonad.Callback[/* &> */11](BsAsyncMonad.Callback[/* seqa */23](/* None */0, /* array */[
                                    (function (param) {
                                        return write(partial_arg, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$1, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$2, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$3, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$4, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$5, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$6, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$7, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$8, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$9, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$10, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$11, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$12, param);
                                      }),
                                    (function (param) {
                                        return write(partial_arg$13, param);
                                      })
                                  ]), (function () {
                                  return (function (param) {
                                      return Fs$LidcoreBsNode.close(fd, param);
                                    });
                                }));
                  }));
    }
  } else {
    var partial_arg$1 = BsAsyncMonad.Callback[/* fail */3];
    return (function (param) {
        return partial_arg$1(Not_supported, param);
      });
  }
}

exports.format_codeToJs = format_codeToJs;
exports.format_codeFromJs = format_codeFromJs;
exports.Not_a_wav_file = Not_a_wav_file;
exports.Not_supported = Not_supported;
exports.read = read$1;
exports.write = write;
/* buf Not a pure module */
